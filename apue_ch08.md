# APUE memo

## Chapter. 8 プロセスの制御

fork, exec 系, _exit, wait, waitpid をマスターすれば良い。
レースコンディションについても fork 関数で学べる

### プロセスID

* 一意のもの
* 再利用されるが、すぐにはされないようになっている
* プロセスごとのファイル名などに利用される

* PID=0 はプロセス・スケジューラ
	* カーネル内部のシステムプロセス
* PID=1 は `init` プロセス
	* カーネルがブート手続きの最後によぶ
	* 設定ファイル群を読み込む
	* マルチユーザモードなどに持っていく
	* システムによって`launchd`だったり`systemd`だったりする
	* `top` でみたら `systemd` という名前だけど、実行されているのは`/sbin/init`だったりする
		* `man init` は `systemd` だった

### getpid/getppid

### 実ユーザIDと実効ユーザ ID

`chmod u+s` と実行ファイルにセットユーザIDビットフラグを立てて、
実行すると、そのプロセスのEUIDにファイルのオーナーをセットする。

たとえば、`passwd` や `login`
実行中のプロセスの実効ユーザIDを変えることで、細かな権限処理を行えるようにする `at` コマンド
 `setuid`, `seteuid` で行うことができる。
 
### fork/vfork

* アドレス空間をコピーする
	* データ/スタック/ヒープをコピーするが共有しない
	* テキストセグメントは共有される
	* 効率の観点からCopy on Writeで必要になったらコピーする
* 親と子のどちらが先に呼ばれるかは不定
* 標準入出力のバッファリングに注意
* ファイル記述子もコピーされるけど、（その中の）ファイルポインタは共有される
	* 同じ記述子なら、`wait` で待たないと、たとえば出力内容が混ざる。
	* 親と子で同一のファイルオフセットを持っておくと便利なことがある
		* ログの書き込みとか

#### fork のポイント

* fork した後、親プロセスが終了したら、子プロセスの親は何に変わるか。
* 待つ親がいなく、終了していない子プロセスは何というか。

### vfork

親のアドレス空間を共有する
書き換えたらダメ

### exec 関数群

fork で exec するとシェルっぽいことができる。

* execlp/execvp
* execle/exeve
* execl/execv
* fexecve

exec 時オープンしている記述子をどうするかというフラグもある。

### exit

* main からの return は exit
* `exit` では標準入出力の後始末がある
* `_Exit` はそれをしない。
* `_exit` はシステムコール

### setuid/setgid

* setuid でそのプロセスの実効ユーザIDを変えることができる。
* スーパユーザ特権があるプロセスなら、3つのIDを変更することができる。

### 解釈実行ファイル

`#!`から始まるファイル
<!--stackedit_data:
eyJoaXN0b3J5IjpbLTM2NDUyNTg5MywyMDU3NzA2NzgsLTEwOD
UyNTQ5ODJdfQ==
-->